![logo](img/logo.png)

# Лекція 6. Pandas: Використання, застосування, приклади

---

![logo_pandas.png](img/l006/logo_pandas.png)

## Необхідні для ознайомлення матеріали

- [Pandas - HomePage](https://pandas.pydata.org/)
- [Pandas - User Guide](https://pandas.pydata.org/docs/user_guide/index.html)
- [Pandas - 10 minutes to pandas](https://pandas.pydata.org/docs/user_guide/10min.html#min)
- [Cheat Sheet](https://github.com/pandas-dev/pandas/blob/main/doc/cheatsheet/Pandas_Cheat_Sheet.pdf)
- [Python Data Science Handbook](https://jakevdp.github.io/PythonDataScienceHandbook/)
    - [Sources of the Hadbook](https://github.com/jakevdp/PythonDataScienceHandbook)

---

## Коротка інформація

У 2008 році AQR Capital Management розпочала розробку pandas. На кінець 2009 року він був вже відкритим кодом і сьогодні його активно підтримує спільнота однодумців у всьому світі, які вкладають свій час і енергію.

Бібліотека Pandas використовується в різних академічних та комерційних галузях, включаючи штучний інтелект (Artificial Intelligence), фінанси, нейробіологію, економіку, статистику, рекламу, веб-аналітику та багато іншого. Розглянемо основні можливості бібліотеки:

- DataFrame - швидкий та ефективний інструмент для маніпулювання даними з вбудованою індексацією. Методи, які потребують високої продуктивності, написані на C або Cython.
- Дозволяє читати та записувати дані різних форматів: CSV(comma-separeted values), таблиці Excel, бази даних SQL, ієрархічний формат HDF Усього налічується 19 підтримуваних форматів.
- Зручний інструмент для роботи з даними.
- Просте керування безладними даними у впорядкованій формі.
- Гнучка зміна форм: додавання, видалення, приєднання нових або старих даних.
- Інтелектуальне індексування, маніпулювання та управління стовпцями та рядками.
- Потужний інструмент для агрегування та перетворення даних, у тому числі великого розміру (BigData).
- Швидке злиття та об'єднання наборів даних, наприклад, два та більше об'єктів DataFrame.
- Підтримка ієрархічного індексування, тобто можливість поєднання стовпців під загальною категорією (MultiIndex).
- Підтримка роботи з датами та часом.

Основні моменти бібліотеки

- Швидкий і ефективний об’єкт DataFrame для обробки даних із вбудованим індексуванням;
- Інструменти для читання та запису даних між структурами даних у пам’яті та різними форматами: CSV та текстові файли, Microsoft Excel, бази даних SQL та швидкий формат HDF5;
- Інтелектуальне вирівнювання даних і інтегрована обробка відсутніх даних: отримайте автоматичне вирівнювання на основі міток під час обчислень і легко маніпулюйте безладними даними в упорядковану форму;
- Гнучка зміна форми та поворот наборів даних;
- Інтелектуальне нарізання на основі міток, модне індексування та піднабір великих наборів даних;
- Стовпці можна вставляти та видаляти зі структур даних для зміни розміру;
- Агрегування або перетворення даних за допомогою потужного механізму групування, що дозволяє виконувати операції розділеного застосування та об’єднання наборів даних;
- Високопродуктивне злиття та об'єднання наборів даних;
- Ієрархічна осьова індексація забезпечує інтуїтивно зрозумілий спосіб роботи з даними великої розмірності в структурі даних меншої розмірності;
- Функціональні можливості часових рядів: генерація діапазону дат і перетворення частоти, статистика рухомого вікна, зміщення дати та відставання. Навіть створюйте часові зсуви для домену та об’єднуйте часові ряди без втрати даних;
- високо оптимізований для продуктивності, та й те, що є критичним, написано на Cython або C

## Детальніше

### Що таке Pandas і навіщо він потрібний

Pandas – це бібліотека для роботи з даними на Python. Вона спрощує життя аналітикам: де раніше використовувалося 10 рядків коду, тепер вистачить одного.

Наприклад, щоб прочитати дані з CSV, у стандартному Python треба спочатку вирішити, як зберігати дані, потім відкрити файл, прочитати його рядково, відокремити значення один від одного й очистити дані від спеціальних символів.

```python
with open('data/file.csv') as f:
    content = f.readlines()
    content = [x.split(',').replace('\n', '') for x in content]
```

У Pandas все простіше. По-перше, не треба думати, як зберігатимуться дані — вони лежать у датафреймі. По-друге, достатньо написати одну команду:

```python
data = pd.read_csv('data/file.csv')
```

### Структури даних: серії та датафрейми

Pandas додає в Python нові структури даних - серії та датафрейми, які використовують NumPy.

Серії (Series) - одновимірні масиви даних. Вони дуже схожі на списки, але відрізняються за поведінкою - наприклад, операції застосовуються до списку повністю, а в серіях - поелементно.

Тобто якщо список помножити на 2, отримайте той же список, повторений 2 рази.

```python
vector = [1, 2, 3]
vector * 2
vector
```

```
[1, 2, 3, 1, 2, 3]
```

А якщо помножити серію, її довжина не зміниться, а елементи подвоїться.

```python
import pandas as pd

series = pd.Series([1, 2, 3])
series * 2
```

```
0    2
1    4
2    6
dtype: int64
```

Зверніть увагу на перший стовпчик виводу.
Це індекс, де зберігаються адреси кожного елемента серії. Кожен елемент потім можна отримувати, звернувшись на потрібну адресу.

```python
series = pd.Series(['foo', 'bar'])
series[0]
```

```
'foo'
```

Ще одна відмінність серій від списків - як індекси можна використовувати довільні значення, це робить дані наочнішими. Припустимо, що ми аналізуємо помісячні продажі. Використовуємо як індекси назви місяців, значеннями буде виторг:

```python
months = ['jan', 'feb', 'mar', 'apr']
sales = [100, 200, 300, 400]
data = pd.Series(data=sales, index=months)
data
```

```
jan    100
feb    200
mar    300
apr    400
dtype: int64
```

Тепер можемо набувати значення кожного місяця:

```python
data['feb']
```

```
200
```

Тому що серії - одновимірний масив даних, у них зручно зберігати виміри по одному.

На практиці зручніше групувати дані разом. Наприклад, якщо ми аналізуємо помісячні продажі, корисно бачити не лише виручку, а й кількість проданих товарів, кількість нових клієнтів та середній чек. Для цього чудово підходять датафрейми.

Датафрейми це таблиці. У них є рядки, колонки та cells (комірка, клітина).

Технічно, колонки датафреймів – це серії. Оскільки в колонках зазвичай описують одні й самі об'єкти, всі колонки ділять той самий індекс:

```python
months = ['jan', 'feb', 'mar', 'apr']
sales = {
    'revenue': [100, 200, 300, 400],
    'items_sold': [23, 43, 55, 65],
    'new_clients': [10, 20, 30, 40]
}
sales_df = pd.DataFrame(data=sales, index=months)
sales_df
```

```
     revenue  items_sold  new_clients
jan      100          23           10
feb      200          43           20
mar      300          55           30
apr      400          65           40
```

### Створюємо датафрейми та завантажуємо в них дані

Буває, що ми не знаємо, що являють собою дані, і не можемо задати структуру заздалегідь. Тоді зручно створити порожній датафрейм і потім заповнити його даними.

```python
df = pd.DataFrame()
df.empty
```

```
True
```

А іноді дані вже є, але зберігаються у змінній зі стандартного Python, наприклад, у словнику.

Щоб отримати датафрейм, цю змінну передаємо в ту саму команду:

```python
df = pd.DataFrame(data=sales, index=months)
df
```

```
     revenue  items_sold  new_clients
jan      100          23           10
feb      200          43           20
mar      300          55           30
apr      400          65           40
```

Трапляється, що в деяких записах не вистачає даних.
Наприклад, подивіться на список goods_sold - у ньому продажі, розбиті за товарними категоріями.
Наприклад, за перший місяць ми продали машини, комп'ютери та програмне забезпечення. У другому машин немає, зате з'явилися велосипеди, а третьому знову з'явилися машини, але велосипеди зникли:

```python
goods_sold = [
    {'computers': 10, 'cars': 1, 'soft': 3},
    {'computers': 4, 'soft': 5, 'bicycles': 1},
    {'computers': 6, 'cars': 2, 'soft': 3}
]
```

Якщо завантажити дані до датафрейму, Pandas створить колонки для всіх товарних категорій і, де це можливо, заповнить їх даними:

```python
pd.DataFrame(goods_sold)
```

```
   computers  cars  soft  bicycles
0         10   1.0     3       NaN
1          4   NaN     5       1.0
2          6   2.0     3       NaN
```

Зверніть увагу, продажі велосипедів у першому та третьому місяці рівні NaN – розшифровується як `Not a Number`. Так Pandas позначає відсутні значення.

### Завантаження даних з файлів

Тепер розберемо, як завантажувати дані із файлів. Найчастіше дані зберігаються в еселівських таблицях або csv-, tsv-файлах.

Екселевський таблиці читаються за допомогою команди `pd.read_excel()`. Параметрами потрібно передати посилання на файл та назву аркуша, який потрібно прочитати.
Команда працює як з xls, так і з xlsx:

```python
pd.read_excel('data/file.xlsx', sheet_name='Sheet1')
```

```
  month  customers  sales
0   feb         10    200
```

Файли формату csv і tsv — це текстові файли, в яких дані відокремлені один від одного комами або табуляцією.

Обидва читаються за допомогою команди .read_csv(), символ табуляції передається параметром sep(від англ. Separator - роздільник):

**CSV**:

```csv
# files/file.csv
month,customers,sales
feb,10,200
```

```python
pd.read_csv('data/file.csv')
```

```
    id month  customers  sales
0  123   feb         10    200
```

**TSV**:

```tsv
# files/file.tsv
month\tcustomers\tsales
feb\t10\t200
```

```python
pd.read_csv('data/file.tsv', sep='\t')
```

```
    id month  customers  sales
0  123   feb         10    200
```

Під час завантаження можна призначити стовпець, який буде індексом.

Уявіть, що ми завантажуємо таблицю із замовленнями. Кожне замовлення має свій унікальний номер, Якщо призначимо цей номер індексом, зможемо вивантажувати дані командою `df[order_id]`. Інакше доведеться писати фільтр `df[df[‘id’] == order_id ]`.

Про те, як отримати дані з датафреймів, я розповім в одному з наступних розділів. Щоб призначити колонку індексом, додамо до команди read_csv()параметр index_col, що дорівнює назві потрібної колонки:

Після завантаження даних у датафрейм, добре їх досліджувати — особливо, якщо вони вам незнайомі.

```python
pd.read_csv('data/file.csv', index_col='id')
```

```
    month  customers  sales
id                         
123   feb         10    200
```

### Досліджуємо завантажені дані

Припустимо, що ми аналізуємо продажі американського інтернет-магазину. У нас є дані про замовлення та клієнтів. Завантажимо файл з продажем інтернет-магазину в змінну orders. Якщо завантажуємо замовлення, вкажемо, що колонка id піде в індекс:

```python
orders = pd.read_csv('data/orders.csv', index_col='id')
```

```
orders
        order_date ship_mode customer_id     sales
id                                                
100006  2014-09-07  Standard    DK-13375   377.970
100090  2014-07-08  Standard    EB-13705   699.192
169502  2017-08-28  Standard    MG-17650   113.410
169551  2017-07-07     First    RL-19615  1344.838
[5009 rows x 4 columns]
...

```

Розглянемо 4 атрибути, які є у будь-якого датафрейму:

- .shape
- .columns
- .dtypes
- .index

##### .shape

Показує, скільки в датафреймі рядків та колонок. Він повертає пару значень, як кортеж (n_rows, n_columns). Спочатку йдуть рядки, потім колонки.

```python
orders.shape
```

```
(5009, 4)
```

У датафреймі 5009 рядків та 4 колонок.

##### .columns

Тепер подивимося, яка інформація міститься у кожній колонці.
За допомогою .columns дізнаємося назви колонок:

```python
orders.columns
```

```
Index(['order_date', 'ship_mode', 'customer_id', 'sales'], dtype='object')
```

Тепер бачимо, що у таблиці є дата замовлення, метод доставки, номер клієнта та виторг.

##### .dtypes

За допомогою `.dtypes` дізнаємося типи даних, що знаходяться в кожній колонці і зрозуміємо, чи їх треба обробляти.
Буває, що цифри завантажуються як текст. Якщо ми спробуємо скласти дві текстові значення '1' + '1', то отримаємо не число 2, а рядок '11':

```python
orders.dtypes
```

```
order_date      object
ship_mode       object
customer_id     object
sales          float64
dtype: objec
```

Тип object – це текст, float64 – це дробове число типу 3,14.

##### .index

За допомогою атрибута `.index` подивимося, як називаються рядки:

```python
orders.index
```

```
Int64Index([100006, 100090, 100293, 100328, 100363, 100391, 100678, 100706,
            100762, 100860,
            ...
            167570, 167920, 168116, 168613, 168690, 168802, 169320, 169488,
            169502, 169551],
           dtype='int64', name='id', length=5009)
```

Очікується, в індексі датафрейму номери замовлень: 100762, 100860 і таке інше.

У колонці `sales` зберігається вартість кожного проданого товару.
Щоб дізнатися розкид значень, середню вартість та медіану, використовуємо метод .describe():

```python
orders.describe()
```

```
              sales
count   5009.000000
mean     458.614666
std      954.730953
min        0.556000
25%       37.630000
50%      151.960000
75%      512.064000
max    23661.228000
```

Нарешті, щоб переглянути кілька прикладів записів датафрейму, використовуємо команди `.head()` і `.sample()`.

```python
orders.head(5)
```

```
        order_date ship_mode customer_id    sales
id                                               
100006  2014-09-07  Standard    DK-13375  377.970
100090  2014-07-08  Standard    EB-13705  699.192
100293  2014-03-14  Standard    NF-18475   91.056
100328  2014-01-28  Standard    JC-15340    3.928
100363  2014-04-08  Standard    JM-15655   21.376
```

```python
orders.sample(5)
```

```
        order_date ship_mode customer_id    sales
id                                               
140641  2016-10-28  Standard    EP-13915   38.190
138331  2015-08-07  Standard    JK-15625  106.800
127306  2017-01-14  Standard    BH-11710  175.086
137001  2017-06-10    Second    GZ-14545   14.700
160066  2014-11-16  Standard    AH-10075    5.220
```

Перша повертає 5 записів із початку датафрейму.
Друга - 5 випадкових записів:

Отримавши перше уявлення про датафрейми, тепер обговоримо, як діставати дані.

### Отримуємо дані з датафреймів

Дані з датафреймів можна отримувати по-різному: вказавши номери колонок і рядків, використовуючи умовні оператори або мову запитів. Розкажу докладніше про кожний спосіб.

Вказуємо потрібні рядки та колонки
Продовжуємо аналізувати продажі інтернет-магазину, які завантажили у попередньому розділі. Припустимо, я хочу вивести стовпець sales. Для цього назву стовпця потрібно укласти в квадратні дужки і поставити після них назви датафрейму orders['sales']:

```python
orders['sales']
```

```
id
100006     377.970
100090     699.192
100293      91.056
100328       3.928
100363      21.376
            ...   
168802      18.368
169320     171.430
169488      56.860
169502     113.410
169551    1344.838
Name: sales, Length: 5009, dtype: float64
```

Зверніть увагу, результат команди – новий датафрейм з таким самим індексом.

Якщо потрібно вивести кілька стовпців, у квадратні дужки потрібно вставити список зі своїми назвами `orders[['customer_id', 'sales']]`.
Будьте уважні: квадратні дужки стали подвійними.
Перші – від датафрейму, другі – від списку:

```python
orders[['customer_id', 'sales']]
```

```
       customer_id     sales
id                          
100006    DK-13375   377.970
100090    EB-13705   699.192
100293    NF-18475    91.056
100328    JC-15340     3.928
100363    JM-15655    21.376
            ...       ...
168802    JO-15145    18.368
169320    LH-16900   171.430
169488    AA-10375    56.860
169502    MG-17650   113.410
169551    RL-19615  1344.838
[5009 rows x 2 columns]

```

Перейдемо до рядків.
Їх можна фільтрувати за індексом та по порядку. Наприклад, ми хочемо вивести тільки замовлення 100363, 100391 і 100706, для цього є команда .loc[]:

```python
show_these_orders = [100363, 100363, 100706]
orders.loc[show_these_orders]
```

```
        order_date ship_mode customer_id    sales
id                                               
100363  2014-04-08  Standard    JM-15655   21.376
100363  2014-04-08  Standard    JM-15655   21.376
100706  2014-12-16    Second    LE-16810  129.440
```

А в інший раз буває потрібно дістати просто замовлення з 1 по 3 по порядку, незалежно від їх номерів у таблиці. Тоді використовують команду .iloc[]:

```python
show_these_orders = [1, 2, 3]
orders.iloc[show_these_orders]
```

```
        order_date ship_mode customer_id    sales
id                                               
100090  2014-07-08  Standard    EB-13705  699.192
100293  2014-03-14  Standard    NF-18475   91.056
100328  2014-01-28  Standard    JC-15340    3.928
```

Можна фільтрувати датафрейми по колонках та стовпцях одночасно:

```python
columns = ['customer_id', 'sales']
rows = [100363, 100363, 100706]
orders.loc[rows][columns]
```

```
       customer_id    sales
id                         
100363    JM-15655   21.376
100363    JM-15655   21.376
100706    LE-16810  129.440
```

Часто ви не знаєте наперед номерів замовлень, які вам потрібні. Наприклад, якщо завдання отримати замовлення, вартістю понад 1000 доларів. Це завдання зручно вирішувати за допомогою умовних операторів.

#### Умовні оператори. Булевий індекс

Наприклад, Завдання: потрібно дізнатися, звідки надходять найбільші замовлення. Почнемо з того, що дістанемо всі покупки вартістю понад 1000 доларів:

```python
filter_large = orders['sales'] > 1000
orders.loc[filter_large]
```

```
        order_date ship_mode customer_id     sales
id                                                
101931  2014-10-28     First    TS-21370  1252.602
102673  2014-11-01  Standard    KH-16630  1044.440
102988  2014-04-05    Second    GM-14695  4251.920
103100  2014-12-20     First    AB-10105  1107.660
103310  2014-05-10  Standard    GM-14680  1769.784
            ...       ...         ...       ...
167318  2017-07-26  Standard    GZ-14545  2012.302
167402  2017-01-13    Second    CP-12085  4619.330
167920  2017-12-09    Second    JL-15835  1827.510
168116  2017-11-04  Same Day    GT-14635  8167.420
169551  2017-07-07     First    RL-19615  1344.838
[620 rows x 4 columns]
```

На початку лекції я згадував, що у серіях всі операції застосовуються по-елементно?
Так от операція `orders['sales'] > 1000` йде по кожному елементу серії і, якщо умова виконується, повертає True. Якщо не виконується – False.
Серію, ми зберігаємо в змінну filter_large.

Друга команда фільтрує рядки датафрейму за допомогою серії. Якщо елемент filter_large дорівнює True, замовлення з'явиться, якщо False ні. Результат — датафрейм із замовленнями вартістю понад 1000 доларів.

Цікаво, скільки найдорожчих замовлень було доставлено першим класом?
Додамо до фільтра ще одну умову:

```python
filter_large = orders['sales'] > 1000
filter_first_class = orders['ship_mode'] == 'First'
orders.loc[filter_large & filter_first_class]
```

```
        order_date ship_mode customer_id     sales
id                                                
101931  2014-10-28     First    TS-21370  1252.602
103100  2014-12-20     First    AB-10105  1107.660
106726  2014-12-06     First    RS-19765  1261.330
112158  2014-12-02     First    DP-13165  1050.600
116666  2014-05-08     First    KT-16480  1799.970
            ...       ...         ...       ...
147886  2017-03-28     First    DH-13075  1435.960
155425  2017-11-10     First    AB-10600  1475.054
162558  2017-10-02     First    Dp-13240  2437.672
165456  2017-11-30     First    TB-21625  1079.316
169551  2017-07-07     First    RL-19615  1344.838
[96 rows x 4 columns]
```

Логіка не змінилася. У змінну filter_largeзберегли серію, що задовольняє умову `orders['sales'] > 1000`. В `filter_first_class` - серію, що задовольняє `orders['ship_mode'] == 'First'`.

Потім об'єднали обидві серії за допомогою логічного 'AND': `filter_first_class & filter_first_class`. Отримали нову серію тієї ж довжини, в елементах якої True тільки замовлення, вартістю більше 1000, доставлених першим класом. Таких умов може бути скільки завгодно.

#### Мова запитів. Метод  .query

Ще один спосіб вирішити попереднє завдання – використовувати мову запитів.
Всі умови пишемо одним рядком `sales > 1000 & ship_mode == 'First'` і передаємо її в метод `.query()`.
Запит виходить компактнішим.

```python
orders.query("sales > 1000 & ship_mode == 'First'")
```

```
        order_date ship_mode customer_id     sales
id                                                
101931  2014-10-28     First    TS-21370  1252.602
103100  2014-12-20     First    AB-10105  1107.660
106726  2014-12-06     First    RS-19765  1261.330
112158  2014-12-02     First    DP-13165  1050.600
116666  2014-05-08     First    KT-16480  1799.970
            ...       ...         ...       ...
147886  2017-03-28     First    DH-13075  1435.960
155425  2017-11-10     First    AB-10600  1475.054
162558  2017-10-02     First    Dp-13240  2437.672
165456  2017-11-30     First    TB-21625  1079.316
169551  2017-07-07     First    RL-19615  1344.838
[96 rows x 4 columns]
```

Також значення для фільтрів можна зберегти в змінній, а у запиті послатись на неї за допомогою символу @: 'sales > @sales_filter'.

```python
sales_filter = 1000
ship_mode_filter = 'First'
orders.query('sales > @sales_filter & ship_mode == @ship_mode_filter')
```

```
        order_date ship_mode customer_id     sales
id                                                
101931  2014-10-28     First    TS-21370  1252.602
103100  2014-12-20     First    AB-10105  1107.660
106726  2014-12-06     First    RS-19765  1261.330
112158  2014-12-02     First    DP-13165  1050.600
116666  2014-05-08     First    KT-16480  1799.970
            ...       ...         ...       ...
147886  2017-03-28     First    DH-13075  1435.960
155425  2017-11-10     First    AB-10600  1475.054
162558  2017-10-02     First    Dp-13240  2437.672
165456  2017-11-30     First    TB-21625  1079.316
169551  2017-07-07     First    RL-19615  1344.838
[96 rows x 4 columns]
```

Розібравшись, як отримувати частини даних з датафрейму, перейдемо до того, як рахувати агреговані метрики: кількість замовлень, сумарний виторг, середній чек, конверсію та інше.

### Рахуємо похідні метрики

Наприклад: порахуємо, скільки грошей магазин заробив за допомогою кожного класу доставлення.

Почнемо з простого - підсумуємо виторг з усіх замовлень. Для цього використовуємо метод .sum():

```python
orders['sales'].sum()
```

```
2297200.8603000003
```

Додамо клас доставки. Перед підсумовуванням згрупуємо дані за допомогою методу .groupby():

```python
orders.groupby('ship_mode')['sales'].sum()
```

```
ship_mode
First       3.514284e+05
Same Day    1.283631e+05
Second      4.591936e+05
Standard    1.358216e+06
Name: sales, dtype: float64
```

`3.514284e+05` - Науковий формат виведення чисел. означає 3.51*10^5.

Нам така точність не потрібна, тому можемо сказати Pandas, щоб округляти значення до сотих:

```python
pd.options.display.float_format = '{:,.1f}'.format
orders.groupby('ship_mode')['sales'].sum()
```

```
ship_mode
First        351,428.4
Same Day     128,363.1
Second       459,193.6
Standard   1,358,215.7
Name: sales, dtype: float64
```

Тепер бачимо суму виручки за кожним класом доставки.

За сумарним виторгом неясно, стає краще чи гірше. Додамо розбивку за датами замовлення:

```python
orders.groupby(['ship_mode', 'order_date'])['sales'].sum()
```

```
ship_mode  order_date
First      2014-01-06      12.8
           2014-01-11       9.9
           2014-01-14      62.0
           2014-01-15     149.9
           2014-01-19     378.6
                          ...  
Standard   2017-12-25   1,338.3
           2017-12-26      63.9
           2017-12-28     589.6
           2017-12-29   1,094.8
           2017-12-30     713.8
Name: sales, Length: 2498, dtype: float64
```

Видно, що виторг стрибає з кожним днем: іноді 10 доларів, а іноді 589.

Цікаво, чи змінюється кількість замовлень або середній чек?
Додамо до вибірки кількість замовлень. Для цього замість .sum() використовуємо метод .agg(), який передамо список з назвами потрібних функцій.

```python
orders.groupby(['ship_mode', 'order_date'])['sales'].agg(['sum', 'count'])
```

```
                         sum  count
ship_mode order_date               
First     2014-01-06    12.8      1
          2014-01-11     9.9      1
          2014-01-14    62.0      1
          2014-01-15   149.9      1
          2014-01-19   378.6      1
                      ...    ...
Standard  2017-12-25 1,338.3      7
          2017-12-26    63.9      3
          2017-12-28   589.6      7
          2017-12-29 1,094.8      4
          2017-12-30   713.8      4
[2498 rows x 2 columns]
```

Бачимо, що стрибає і середній чек.

Цікаво, а який був найвдаліший день?
Щоб дізнатися, відсортуємо датафрейм, що вийшов: виведемо 10 самих грошових днів за виручкою:

```python
orders.groupby(['ship_mode', 'order_date'])['sales'].agg(['sum']).sort_values(by='sum', ascending=False).head(10)
```

```
                          sum
ship_mode order_date         
Standard  2014-03-18 26,908.4
          2016-10-02 18,398.2
First     2017-03-23 14,299.1
Standard  2014-09-08 14,060.4
First     2017-10-22 13,716.5
Standard  2016-12-17 12,185.1
          2017-11-17 12,112.5
          2015-09-17 11,467.6
          2016-05-23 10,561.0
          2014-09-23 10,478.6
```

Найвдалішого дня — 18 березня 2014 року — магазин заробив близько 27 тисяч доларів за допомогою стандартного класу доставлення.

Цікаво, звідки були клієнти, котрі зробили ці замовлення?
Щоб дізнатися, треба поєднати дані про замовлення з даними клієнтів.

#### Об'єднуємо кілька датафреймів

Досі ми дивилися лише на таблицю із замовленнями.
Але ж ми маємо ще дані про клієнтів інтернет-магазину. Завантажимо їх у змінну customers і подивимося, що вони являють собою:

```python
customers = pd.read_csv('data/customers.csv', index_col='id')
```

```
                       name      segment           state               city
id                                                                         
CG-12520        Claire Gute     Consumer        Kentucky          Henderson
DV-13045    Darrin Van Huff    Corporate      California        Los Angeles
SO-20335     Sean O'Donnell     Consumer         Florida    Fort Lauderdale
BH-11710    Brosina Hoffman     Consumer      California        Los Angeles
AA-10480       Andrew Allen     Consumer  North Carolina            Concord
                     ...          ...             ...                ...
CJ-11875       Carl Jackson    Corporate    Pennsylvania       Philadelphia
RS-19870         Roy Skaria  Home Office            Iowa         Burlington
SC-20845         Sung Chung     Consumer        Illinois  Arlington Heights
RE-19405    Ricardo Emerson     Consumer            Ohio               Kent
SM-20905  Susan MacKendrick     Consumer            Ohio             Newark
[793 rows x 4 columns
```

Ми знаємо тип клієнта, місце його проживання, його ім'я та ім'я контактної особи.
Кожен клієнт має унікальний номер id.
Той самий номер лежить у колонці customer_id таблиці orders.
Отже, ми можемо знайти, які замовлення зробив кожен клієнт.
Наприклад, подивимося, замовлення користувача CG-12520:

```python
cust_filter = 'CG-12520'
orders.query('customer_id == @cust_filter')
```

```
        order_date ship_mode customer_id  sales
id                                             
152156  2016-11-08    Second    CG-12520  993.9
164098  2017-01-26     First    CG-12520   18.2
123918  2015-10-15  Same Day    CG-12520  136.7
```

Повернімося до завдання з попереднього розділу: дізнатися, що за клієнти, які зробили 18 березня замовлення зі стандартною доставкою. Для цього поєднаємо таблиці з клієнтами та замовленнями. Датафрейми об'єднують за допомогою методів `.concat()`, `.merge()`, `.join()`.
Всі вони роблять майже одне саме, але відрізняються синтаксисом — на практиці достатньо вміти користуватися одним з них.

Покажу на прикладі .merge():

```python
new_df = pd.merge(orders, customers, how='inner', left_on='customer_id', right_index=True)
new_df.columns
```

```
Index(['order_date', 'ship_mode', 'customer_id', 'sales', 'name', 'segment',
       'state', 'city'],
      dtype='object')

```

В `.merge()` спочатку вказуэмо назви датафреймів, які ми хочемо об'єднати.
Потім уточнюємо, як саме їх об'єднати та які колонки використовувати як ключ.
**Ключ** - це колонка, що зв'язує обидва датафрейми.
У нашому випадку - номер клієнта. У таблиці із замовленнями він у колонці `customer_id`, а таблиці із клієнтами - в індексі.
Тож у команді ми пишемо: `left_on='customer_id', right_index=True`

### Приклад

Знайдемо 5 міст, які принесли найбільшу виручку у 2016 році.

Для початку відфільтруємо замовлення з 2016 року:

```python
orders_2016 = orders.query("order_date >= '2016-01-01' & order_date <= '2016-12-31'")
orders_2016.head()
```

```
        order_date ship_mode customer_id   sales
id                                              
100041  2016-11-20  Standard    BF-10975   328.5
100083  2016-11-24  Standard    CD-11980    24.8
100153  2016-12-13  Standard    KH-16630    63.9
100244  2016-09-20  Standard    GM-14695   475.7
100300  2016-06-24    Second    MJ-17740 4,823.1
```

Місто – це атрибут користувачів, а не замовлень. Тобто, додамо інформацію про користувачів:

```python
with_customers_2016 = pd.merge(customers, orders_2016, how='inner', left_index=True,
                               right_on='customer_id')
with_customers_2016.head(3)
```

```
                   name    segment       state  ... ship_mode customer_id sales
id                                              ...                            
152156      Claire Gute   Consumer    Kentucky  ...    Second    CG-12520 993.9
106656  Darrin Van Huff  Corporate  California  ...     First    DV-13045  23.0
138688  Darrin Van Huff  Corporate  California  ...    Second    DV-13045  14.6
[3 rows x 8 columns]
```

Сгрупуємо датафрейм по містах, і порахуємо виторг:

```python
grouped_2016 = with_customers_2016.groupby('city')['sales'].sum()
grouped_2016.head()
```

```
city
Akron               1,763.0
Albuquerque           692.9
Amarillo              197.2
Arlington           5,672.1
Arlington Heights      14.1
Name: sales, dtype: float64
```

Відсортуємо за зменшенням продажу та залишимо TOP-5:

```python
top5 = grouped_2016.sort_values(ascending=False).head(5)
top5
```

```
city
New York City   53,094.1
Philadelphia    39,895.5
Seattle         33,955.5
Los Angeles     33,611.1
San Francisco   27,990.0
Name: sales, dtype: float64
```

Ready !!!

### Висновки до теми

- позноймились з бібліотекою пандас
- навчились читатати та обробляти данні
- готувати датафрейми для аналізу

---

# [Література та посилання](links.md)

---

# [На головну сторінку ...](../README.md)
